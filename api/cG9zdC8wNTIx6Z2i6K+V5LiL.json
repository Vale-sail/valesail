{"title":"0521面试下","date":"2020-05-24T21:15:05.000Z","author":"Vale Sail","slug":"0521面试下","updated":"2021-03-04T13:48:16.047Z","content":"<p>进程线程</p>\n<blockquote>\n<p>进程是资源分配的最小单位，线程是CPU调度的最小单位<br>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小.</p>\n</blockquote>\n<h4 id=\"进程通信方式\">进程通信方式<a href=\"post/0521面试下#进程通信方式\"></a></h4><ol>\n<li>管道<ol>\n<li>半双工（数据只能在一个方向上流动）</li>\n<li>必须具有亲缘关系的进程才能通信</li>\n<li>存在于内存中，</li>\n</ol>\n</li>\n<li><p>FIFO</p>\n<blockquote>\n<p>命名管道，它是一种文件类型。</p>\n<ol>\n<li>FIFO可以在无关的进程之间交换数据，与无名管道不同。</li>\n<li>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>消息队列</p>\n<blockquote>\n<p>消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p>\n<ol>\n<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li>\n<li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</li>\n<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</li>\n</ol>\n</blockquote>\n</li>\n<li>信号量<blockquote>\n<p>一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>\n<ol>\n<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>\n<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li>\n<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li>\n<li>支持信号量组。</li>\n</ol>\n</blockquote>\n</li>\n<li>共享内存<blockquote>\n<p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p>\n<ol>\n<li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li>\n<li>因为多个进程可以同时操作，所以需要进行同步。</li>\n<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"协程\">协程<a href=\"post/0521面试下#协程\"></a></h3><blockquote>\n<p>协程就是用户空间下的线程。比线程的开销更小，基于用户的运行时进行控制上下文切换。</p>\n</blockquote>\n<p>进程是资源分配的基本单元，一个进程至少拥有一个线程，同进程下的线程共享进程的地址空间和资源。线程基于抢占式的执行方式，CPU进行调度；协程是轻量级的线程，协程有用户进行调度:每次暂停保存状态，恢复时恢复转台，进入上次的调用状态，协程是用户主动释放使用权进行切换。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">golang 协程模型(M:N):</span><br><span class=\"line\">\tG：Groutine，协程</span><br><span class=\"line\">\tM：Machine，内核线程，对应CPU</span><br><span class=\"line\">\tP：Processor，G和M的调度对象，包含LRQ</span><br><span class=\"line\">每个Processor对象都拥有一个LRQ（Local Run Queue），未分配的Goroutine对象保存在GRQ（Global Run Queue ）中，等待分配给某一个P的LRQ中，每个LRQ里面包含若干个用户创建的Goroutine对象，同时Processor作为桥梁对Machine和Goroutine进行了解耦，也就是说Goroutine如果想要使用Machine需要绑定一个Processor才行</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>Linux操作系统的体系架构<ol>\n<li>内核态<blockquote>\n<p>运行操作系统程序，可以随意操作硬件，访问内存不受限制.</p>\n</blockquote>\n</li>\n<li>用户态<blockquote>\n<p>运行用户程序</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>状态切换<ol>\n<li>用户态—&gt;内核态：主动发起系统调用，产生中断、异常、陷入机制（访管指令）</li>\n</ol>\n</li>\n<li>区别<ol>\n<li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的</li>\n<li>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</li>\n</ol>\n</li>\n</ol>\n","prev":{"title":"golang界面程序","slug":"golang界面程序"},"next":{"title":"0522坑","slug":"0522坑"},"link":"https://vale-sail.github.io/post/0521面试下/"}