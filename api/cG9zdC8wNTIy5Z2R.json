{"title":"0522坑","date":"2020-05-24T20:40:00.000Z","author":"Vale Sail","slug":"0522坑","updated":"2021-03-04T13:48:16.047Z","content":"<h4 id=\"遇到的坑\">遇到的坑<a href=\"post/0522坑#遇到的坑\"></a></h4><p>今天遇到一个单例实现的坑 直接上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trait SingletonInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    protected static $instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static function instance()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!static::$instance) &#123;</span><br><span class=\"line\">            static::$instance = new static;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return static::$instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法看起来没有什么问题，使用起来也是 类直接使用 这个trait<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    use SingletonInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    public function show()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        echo &quot;A&quot;, PHP_EOL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>直接使用A::instance() 就能获取A的单例，看起来没有问题，使用也很方便。但是如果有一个类是这样的 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class B extends A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public function show()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        echo &quot;B&quot;, PHP_EOL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要获取B的实例，使用B::ininstance()，根据继承和组合 也就能实现获取，这些都没有问题。但是如果是代码使用逻辑中同时使用了A和B这两个类的实例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::instance()-&gt;show();</span><br><span class=\"line\">B::instance()-&gt;show();</span><br></pre></td></tr></table></figure></p>\n<p>那会输出什么，你理想的可能是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure></p>\n<p>但是实际上可能并不是这样，而是下面是这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure></p>\n<p>为什么喃，因为在B是继承与A的，B是A的子类，在直接使用A::instance()时，A的静态变量instance被初始化为对象A，但是在B使用B::instance()获取单例时，这个时候由于B是A子类，A中的instance已经被初始化为A，这个时候B::instance() 返回的就已经不再是B的实例了，而是A的一个实例，由于B是A的子类，那么可能B的实例会被用来调用一下B特有的方法，但是实例确实A，所以会提示undefined 的问题。</p>\n<h3 id=\"InnoDb和MyISAM\">InnoDb和MyISAM<a href=\"post/0522坑#InnoDb和MyISAM\"></a></h3><ol>\n<li>事务和外键<ol>\n<li>InnoDb支持事物，具有A(原子性)C(一致性)I(隔离性)D(持久性)的四大特性。<ol>\n<li>隔离性（RU RC RR serialize）</li>\n</ol>\n</li>\n<li>InnoDb使用行级锁(索引命中锁索引，未命中锁表)，并发性高。MyISAM使用表级锁，并发性底；并且读写相互阻塞。</li>\n</ol>\n</li>\n<li>存储<ol>\n<li>MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型， .frm文件存储表定义，数据文件的扩展名为.MYD，  索引文件的扩展名是.MYI，数据库转移简单</li>\n<li>InnoDB，基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，</li>\n</ol>\n</li>\n<li>索引<ol>\n<li>InnoDB（索引组织表）使用的聚簇索引、索引就是数据，顺序存储，因此能缓存索引，也能缓存数据</li>\n<li>MyISAM（堆组织表）使用的是非聚簇索引、索引和文件分开，随机存储，只能缓存索引</li>\n</ol>\n</li>\n</ol>\n","prev":{"title":"0521面试下","slug":"0521面试下"},"next":{"title":"0519面试上","slug":"0519面试"},"link":"https://vale-sail.github.io/post/0522坑/"}