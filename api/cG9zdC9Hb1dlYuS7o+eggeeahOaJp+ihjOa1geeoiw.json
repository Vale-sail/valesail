{"title":"GoWeb代码的执行流程","date":"2019-05-07T15:59:00.000Z","slug":"GoWeb代码的执行流程","tags":["golang"],"updated":"2021-03-04T13:48:16.047Z","content":"<h1 id=\"Go代码的执行流程\">Go代码的执行流程<a href=\"post/GoWeb代码的执行流程#Go代码的执行流程\"></a></h1><p>handler和handlerFunc 都居于ServerHttp的方法</p>\n<p>Handler接口存在ServeHTTP方法，但是http.handler 定义的函数并没有这个方法，所以进行类型强制转换，是自定义函数具有ServerHttp方法</p>\n<p>通过对http包的分析之后，现在让我们来梳理一下整个的代码执行过程。</p>\n<ol>\n<li><p>首先调用Http.HandleFunc </p>\n<ol>\n<li>调用了DefaultServeMux的HandleFunc</li>\n<li>调用了DefaultServeMux的Handle</li>\n<li>往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则</li>\n</ol>\n</li>\n<li><p>调用http.ListenAndServe(“:9090”, nil)</p>\n<ol>\n<li>实例化Server</li>\n<li>调用Server的ListenAndServe()</li>\n<li>调用net.Listen(“tcp”, addr)监听端口</li>\n<li>启动一个for循环，在循环体中Accept请求</li>\n<li>对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()</li>\n<li>读取每个请求的内容w, err := c.readRequest()</li>\n<li>判断handler是否为空，如果没有设置handler（这个例子就没有设置handler），handler就设置为DefaultServeMux</li>\n<li>调用handler的ServeHttp </li>\n<li>在这个例子中，下面就进入到DefaultServeMux.ServeHttp</li>\n<li>根据request选择handler，并且进入到这个handler的ServeHTTP</li>\n</ol>\n</li>\n<li><p>mux.handler(r).ServeHTTP(w, r)</p>\n<ol>\n<li>选择handler：<ol>\n<li>判断是否有路由能满足这个request（循环遍历ServerMux的muxEntry）</li>\n<li>如果有路由满足，调用这个路由handler的ServeHttp</li>\n<li>如果没有路由满足，调用NotFoundHandler的ServeHttp</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","prev":{"title":"纸飞机使用帮助mark","slug":"小火箭帮助"},"next":{"title":"CSV导出遇到的问题","slug":"CSV格式特殊处理"},"link":"https://vale-sail.github.io/post/GoWeb代码的执行流程/","toc":[{"title":"Go代码的执行流程","id":"Go代码的执行流程","index":"1"}]}