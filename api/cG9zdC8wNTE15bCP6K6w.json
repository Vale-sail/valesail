{"title":"0515小记","date":"2020-05-16T13:14:59.000Z","author":"Vale Sail","slug":"0515小记","updated":"2021-03-04T13:48:16.047Z","content":"<h4 id=\"面试\">面试<a href=\"post/0515小记#面试\"></a></h4><blockquote>\n<p>早上去了某互联网公司，做垂直电商的，面试官问的问题我又没有答上来。但是这次遇到的上一次面试问的问题，我全部答上来了，这也算是一个小小的进步吧</p>\n</blockquote>\n<ol>\n<li>golang的map数据结构底层用什么实现的？<blockquote>\n<p>第一瞬间没有反应过来，错理解hash表是怎么实现的了，导致没有答上来</p>\n</blockquote>\n</li>\n</ol>\n<p>golang的map底层是基于hash表(散列表)进行实现的，hash底层是基于数组+链表(hash冲突解决)实现。高位hash确定bucket位置，低位hash确定bucket中的位置</p>\n<ol>\n<li>协程</li>\n</ol>\n<p>进程:拥有资源和独立运行的最小单位，操作系统级别<br>线程:程序执行的最小单位(内核态)，由内核调度<br>协程:用户级的多线程，由用户或者runtime 进行调度<br>和线程的实现原理一样，只是线程使用内核调度，存在上线切换，协程在用户应用级别模拟调度，避免频繁的上线切换；<br>常见的并发通信模型:消息和共享内存；golang使用消息机制(chanel)来进行通信；channel和select模型<br>协程调度:G(协程) P(处理器) M(线程) ，基于M产生P，基于P调度运行G；使用runtime.GOMAXPROCS() 设置数量。P维护一个包含的G队列，使用队列轮转进行调度，但是在G产生系统调用时，M释放P，P在缓存池中重新获取M，进行绑定执行。如果P的队列中没有G，P会查询全局队列，进行执行</p>\n<ol>\n<li><p>B树和B+树的区别及其层数计算</p>\n<blockquote>\n<p>B树:平衡多叉树，二叉树的更矮<br>B+树: 非叶子节点不存储数据，只做索引，子节点数据大小有序，叶子节点相连</p>\n<ol>\n<li>B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>\n<li>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>\n<li>B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>\n<li>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>\n<li>B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>ES扩容</p>\n<ol>\n<li>垂直扩容: 直接使用更大容量的机器替换</li>\n<li>水平扩容: 新增机器节点加入es集群，es自主发现并进行副本均衡。超过分片数量，增加副本数量。</li>\n</ol>\n</li>\n<li><p>raft协议</p>\n</li>\n<li><p>数据库优化</p>\n<ol>\n<li>数据库表结构优化</li>\n<li>数据库拆分<ol>\n<li>读写分离 主从</li>\n<li>垂直拆分</li>\n<li>水平拆分</li>\n</ol>\n</li>\n<li>索引优化<ol>\n<li>联合索引，最左原则</li>\n<li>前缀索引(减少索引长度，需要回表)</li>\n<li>全匹配（=   in between）</li>\n<li>纯索引查询，减少回表流程</li>\n<li>自增主键减少数据插入时树的调整</li>\n<li>使用其他的工具进行辅助查询</li>\n</ol>\n</li>\n<li>SQL优化</li>\n</ol>\n</li>\n<li>接口QPS</li>\n<li>Redis集群<ol>\n<li>主从复制模式，提升redis的读取能力。</li>\n<li>redis Sentinal基于高可用，在master宕机时，自动选举新的master提供写服务。</li>\n<li>Redis Cluster 基于一致性的hash的虚拟hash槽，自动分区</li>\n</ol>\n</li>\n</ol>\n","prev":{"title":"0518算法","slug":"0518"},"next":{"title":"0514 小记","slug":"0514面试总结"},"link":"https://vale-sail.github.io/post/0515小记/"}