{"title":"SOLID原则","date":"2020-04-16T22:20:00.000Z","author":"Vale Sail","slug":"SOLID原则","tags":["设计模式"],"categories":["学习笔记"],"updated":"2021-03-04T13:48:16.047Z","content":"<p>SOLID原则</p>\n<ol>\n<li><p>单一职责原则</p>\n<blockquote>\n<p>一个模块或类值完成一个职责(功能)  功能单一 </p>\n<p>代码高内聚 低耦合 </p>\n<p>判断标准</p>\n<blockquote>\n<p>类的代码行数过多 </p>\n<p>依赖的过大</p>\n<p>私有方法过多</p>\n<p>类中的大量方法集中操作某些属性</p>\n</blockquote>\n</blockquote>\n</li>\n<li><p>开闭原则</p>\n<blockquote>\n<p>对扩展开发 对修改关闭</p>\n<blockquote>\n<p>对属性的扩展开放 对方法的修改关闭(最小的改动代价实现新的功能开发)</p>\n<p>扩展 引入 平行结构 派生类</p>\n<p>修改 发生在高层次中 做到高内聚</p>\n<p>扩展  低层次之间可以互相替换</p>\n</blockquote>\n</blockquote>\n</li>\n<li><p>里氏替换原则</p>\n<blockquote>\n<p>指导继承关系中子类改如何设计 子类可以修改实现逻辑 但是不能修改原有函数的约定 不能修改对于输入 输出 异常 和特殊说明的约定<br>多态是一种思路</p>\n</blockquote>\n</li>\n<li><p>接口隔离原则</p>\n<blockquote>\n<p>微服务级别 前后隔离 前台业务和后台业务API进行隔离 有些只能后台使用的API放到后台隔离，业务的拆分</p>\n<p>API隔离 把方法拆分粒度更加的细致，让调用者只依赖于细粒度的方法</p>\n<p>接口设计尽量单一</p>\n</blockquote>\n</li>\n<li><p>依赖翻转</p>\n<blockquote>\n<p>控制翻转</p>\n<blockquote>\n<p>把流程的控制权由程序员(if)交给代码(配置实现)<br>依赖注入<br>不在类中自己创建对象，而是将对象在外部初始化通过参数的方式传递给类使用<br>依赖翻转原则<br>高层模块不依赖于底层模块，而是共同依赖于同一个抽象<br>抽象不依赖具体的实现细节，具体的实现细节依赖于抽象<br>参考框架中的IOC和DI </p>\n</blockquote>\n</blockquote>\n</li>\n</ol>\n","prev":{"title":"链表","slug":"链表"},"next":{"title":"设计原则","slug":"设计原则"},"link":"https://vale-sail.github.io/post/SOLID原则/"}