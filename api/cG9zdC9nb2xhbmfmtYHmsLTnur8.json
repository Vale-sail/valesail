{"title":"golang流水线","date":"2020-06-07T15:32:15.000Z","author":"Vale Sail","slug":"golang流水线","updated":"2021-03-04T13:48:16.047Z","content":"<ol>\n<li>流水线工作模式<blockquote>\n<p>数据通过chan进行流动，每个小的任务由每个协程进行处理</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"chan\">chan<a href=\"post/golang流水线#chan\"></a></h5><blockquote>\n<p>协程之间通信的数据通道，基于mutx.lock 实现读写安全</p>\n</blockquote>\n<ol>\n<li>chan支持各种数据类型，在申明chan时指定 var c chan string</li>\n<li>chan的底层结构<br>20190307092857857.png<br><img src=\"/images/chan结构.png\" alt=\"upload successful\"></li>\n<li>chan分类<ol>\n<li>有缓冲chan，在创建时指定缓冲区大小</li>\n<li>无缓冲chan:缓冲区大小为1的chan</li>\n</ol>\n</li>\n<li><p>chan 在缓冲区未满时，写入不阻塞，但是缓冲区满，阻塞写入</p>\n<blockquote>\n<p>chan 读取</p>\n<ol>\n<li>val,ok := &lt;- c ;chan 关闭时ok为false</li>\n<li>for val := range c ; chan关闭时自动退出循环</li>\n</ol>\n</blockquote>\n</li>\n<li><p>chan 在缓冲去无数据时，读取阻塞；</p>\n<blockquote>\n<p>chan 写入<br>c &lt;- val</p>\n</blockquote>\n</li>\n<li>在作为参数传递时，可以为chan指定方向（只读或只写），防止chan写入不可控</li>\n<li>chan使用close函数进行关闭；chan的关闭应该有sender进行关闭</li>\n<li>使用select case 来处理多个chan；但是select 无法感知chan的关闭，需要使用val，ok的方式来判断是否关闭；nil的chan 永远阻塞case；</li>\n</ol>\n<h4 id=\"协程\">协程<a href=\"post/golang流水线#协程\"></a></h4><blockquote>\n<p>轻量级的线程，用户态进行自主调度；</p>\n</blockquote>\n<ol>\n<li>golang runtime基于GMP调度；</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">概念</span><br><span class=\"line\">\tG: goroutine，每个G都代表1个goroutine</span><br><span class=\"line\">\tM: 工作线程，是Go语言定义出来在用户层面描述系统线程的对象 ，每个M代表一个系统线程</span><br><span class=\"line\">\tP: 处理器，它包含了运行Go代码的资源。</span><br><span class=\"line\">每个M拥有一个或多个P，每个P运行一个或多个G；每个P拥有自己的G队列</span><br><span class=\"line\"></span><br><span class=\"line\">调度 </span><br><span class=\"line\">\t全局队列（Global Queue）：存放等待运行的G。</span><br><span class=\"line\">\tP的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</span><br><span class=\"line\">\tP列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个。</span><br><span class=\"line\">\tM：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</span><br><span class=\"line\">    </span><br><span class=\"line\">使用 go tool trace 可视化的观察协程的运行</span><br></pre></td></tr></table></figure>\n<p>协程池: 为任务建立指定数量的协程来进行处理；不同任务间使用chan进行通信；但是协程不能被强制结束，只能等待他处理完成主动退出，或者遇到错误进行退出<br>在流水线模型中，由流水线的最初消息或第一个任务处理强制关闭消息，后续任务协程监听 chan 关闭消息</p>\n<ol>\n<li><p>for range 退出</p>\n<blockquote>\n<p>for range 能够感受到chan的关闭了，当chan关闭之后，for range循环自动结束</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go func(in &lt;-chan int) &#123;</span><br><span class=\"line\">    for x := range in &#123;</span><br><span class=\"line\">        fmt.Printf(&quot;Process %d\\n&quot;, x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(inCh)</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>使用,ok退出</p>\n<blockquote>\n<p>chan读取的时候，val,ok := &lt;- chan,如果chan关闭时ok为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if v, ok := &lt;-c; ok &#123;</span><br><span class=\"line\">\tfmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &#123;</span><br><span class=\"line\">\tcase val, ok := &lt;-c:</span><br><span class=\"line\">\t\tif !ok &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(val)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>使用关闭通道<blockquote>\n<p>建立一个特殊的chan 用来表示需要协程关闭</p>\n</blockquote>\n</li>\n<li>使用context<blockquote>\n<p>使用CancelContext 来关闭协程；</p>\n</blockquote>\n</li>\n</ol>\n","prev":{"title":"字节面试-PHP","slug":"字节面试"},"next":{"title":"golang界面程序","slug":"golang界面程序"},"link":"https://vale-sail.github.io/post/golang流水线/"}