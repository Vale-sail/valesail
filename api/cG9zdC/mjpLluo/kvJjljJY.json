{"title":"排序优化和查找","date":"2020-04-28T21:29:44.000Z","author":"Vale Sail","slug":"排序优化","updated":"2021-03-04T13:48:16.047Z","content":"<h5 id=\"排序优化\">排序优化<a href=\"post/排序优化#排序优化\"></a></h5><h6 id=\"快排-元素选择优化\">快排 元素选择优化<a href=\"post/排序优化#快排-元素选择优化\"></a></h6><p>在接近有序或者有序的情况下，快排的复杂度为o(n)</p>\n<blockquote>\n<ol>\n<li>三位置数取中法</li>\n<li>随机法</li>\n<li>数据量小 可以使用归并排序，额外空间消耗来换取速度</li>\n</ol>\n</blockquote>\n<h5 id=\"二分查找\">二分查找<a href=\"post/排序优化#二分查找\"></a></h5><blockquote>\n<ol>\n<li>时间复杂度为 o(logN)</li>\n<li>二分思想</li>\n<li>基于有序数据，依赖数组(连续的内存空间，直接定位中间值)</li>\n<li>数据太小 优势不明显</li>\n<li>数据太大 连续内存要求苛刻</li>\n<li>适用于近似查找</li>\n</ol>\n</blockquote>\n<h5 id=\"跳表\">跳表<a href=\"post/排序优化#跳表\"></a></h5><blockquote>\n<ol>\n<li>以空间换时间 多层索引结构 </li>\n<li>基于链表 高效的插入和删除 易于扩展</li>\n<li>动态索引更新:防止索引不更新退化为单链表 可以使用随机函数处理</li>\n<li>redis中使用跳表来进行存储</li>\n</ol>\n</blockquote>\n<h5 id=\"hash表\">hash表<a href=\"post/排序优化#hash表\"></a></h5><blockquote>\n<ol>\n<li>使用数组支持随机访问的特性。按照一定的hash方式进行计算得到hash值直接访问数组</li>\n</ol>\n</blockquote>\n<h5 id=\"hash冲突\">hash冲突<a href=\"post/排序优化#hash冲突\"></a></h5><blockquote>\n<p>由于hash函数最后得到hash值存在冲突，可能出现原本的位置已经有值了。</p>\n</blockquote>\n<h6 id=\"解决\">解决<a href=\"post/排序优化#解决\"></a></h6><blockquote>\n<ol>\n<li>开放寻址 如果hash值存在冲突 就写入到下一个空地址，查找时根据hash值进行查找，</li>\n<li>链表法 每个hash值 对应这一个链表 每次追加到链表尾部</li>\n</ol>\n</blockquote>\n","prev":{"title":"Hash函数","slug":"Hash函数"},"next":{"title":"线性时间复杂度的排序","slug":"线性时间复杂度的排序"},"link":"https://vale-sail.github.io/post/排序优化/"}