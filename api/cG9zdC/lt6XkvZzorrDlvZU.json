{"title":"PHPUnit的一点点","date":"2020-04-16T22:38:00.000Z","author":"Vale Sail","slug":"工作记录","tags":["PHP","单元测试"],"categories":["工作终结"],"updated":"2021-03-04T13:48:16.047Z","content":"<h5 id=\"PHPUnit\">PHPUnit<a href=\"post/工作记录#PHPUnit\"></a></h5><p>最近优化了一段代码，但是测试排期忙不过来，自己又不想去做页面测试，于是有了写单元测试的想法。然后学习了PHPUnit，被PHPUnit的魅力深深吸引。但是也遇到了一些问题。</p>\n<h5 id=\"在调用第三方服务时，可以使用测试提升模拟来模拟第三方的请求\">在调用第三方服务时，可以使用测试提升模拟来模拟第三方的请求<a href=\"post/工作记录#在调用第三方服务时，可以使用测试提升模拟来模拟第三方的请求\"></a></h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 为 SomeClass 类创建替身对象。</span><br><span class=\"line\">$stub = $this-&gt;createMock(SomeClass::class);</span><br><span class=\"line\">// 配置替身方法。</span><br><span class=\"line\">$stub-&gt;method(&apos;doSomething&apos;)</span><br><span class=\"line\">     -&gt;willReturn(&apos;foo&apos;);</span><br><span class=\"line\">// 现在调用替身方法。</span><br><span class=\"line\">$this-&gt;assertEquals(&apos;foo&apos;, $stub-&gt;doSomething());</span><br></pre></td></tr></table></figure>\n<p>如果类存在构造方法可以查询文档<br>可以屏蔽构造方法或者把参数传递给构造函数<br>具体可以查看文档<a href=\"https://phpunit.readthedocs.io/zh_CN/latest/test-doubles.html\" target=\"_blank\" rel=\"noopener\">https://phpunit.readthedocs.io/zh_CN/latest/test-doubles.html</a></p>\n<hr>\n<p>由于在开发中可能某些服务是在内部创建实例而不是以注入的方式创建实例，并且内部创建时使用单例模式来生成。这种不是我们应该怎么来处理喃。</p>\n<p>常见的单例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trait Singleton</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    protected static $instances = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Get instance of the derived class.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return static</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static function instance()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        $className = get_called_class();</span><br><span class=\"line\">        if (is_null(self::$instances)) &#123;</span><br><span class=\"line\">            self::$instances = new $className;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return self::$instances;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码的单例，外部无法修改对象的生成，从而导致无法使用我们创建的替身。解决方法</p>\n<ol>\n<li>给测试类创建替身 然后使用attch方法 其中依赖的给注入</li>\n<li>使用反射的方式，将需要使用替身的类，使用反射机制将其反射，由于上述代码中的$instances是受保护的方法，可以采用使用反射属性的setAccessible方法将其打开允许访问，然后使用setValue 设置$instances为生成的提升<br>代码实现如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stub = $this-&gt;createMock($mockClass);</span><br><span class=\"line\">$stub-&gt;method($mockMethod)</span><br><span class=\"line\">     -&gt;willReturn($returnValue);</span><br><span class=\"line\">$this-&gt;assertEquals($returnValue, $stub-&gt;$mockMethod(...$methodParam));</span><br><span class=\"line\">$reflectionClass = new \\ReflectionClass($mockClass);</span><br><span class=\"line\">$reflectionProperty = $reflectionClass-&gt;getProperty(&apos;instances&apos;);</span><br><span class=\"line\">$reflectionProperty-&gt;setAccessible(1);</span><br><span class=\"line\">$reflectionProperty-&gt;setValue($stub)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"推代码自动运行测试用例\">推代码自动运行测试用例<a href=\"post/工作记录#推代码自动运行测试用例\"></a></h4><ol>\n<li>借助gitlab的CI/CD功能实现推代码自动执行某些功能</li>\n<li>项目中可以配置 phpunit.xml 指定phpunit的配置</li>\n<li>结合PHPStorm 运行phpunit 还可以直接查看 单元测试的代码覆盖了</li>\n<li>当然还可以指定生成html格式代码覆盖文件<blockquote>\n<p>代码覆盖率需要依赖xdebug</p>\n</blockquote>\n</li>\n</ol>\n","prev":{"title":"OD岗位面试 1轮","slug":"OD岗位面试"},"next":{"title":"链表","slug":"链表"},"link":"https://vale-sail.github.io/post/工作记录/"}